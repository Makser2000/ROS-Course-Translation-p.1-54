# 1. Рамки данного тома

В томе 1 мы научились программировать робота, используя фундаментальные компоненты из ROS, включая управление мобильной базой, SLAM, роботизированное зрение \(OpenCV, OpenNI и немного PCL\), распознавание речи и совместное управление с помощью сервоприводов Dynamixel. В этом томе мы рассмотрим некоторые из более продвинутых концепций и пакетов ROS, которые необходимы для программирования по-настоящему автономного поведения роботов, в том числе:

* менеджеры по работе с исполнительными задачами, такие как [smach](http://wiki.ros.org/smach/Documentation) и [behavior trees](http://wiki.ros.org/decision_making/Tutorials/BehaviorTree)
* создание модели для своего робота с использованием [URDF/Xacro](http://wiki.ros.org/xacro) описаний, в том числе

  наклонно-поворотная головка, многошарнирные рукава и захваты, телескопическое туловище, и размещение датчиков, таких как лазерный сканер

* настройка пакетов [arbotix](http://wiki.ros.org/arbotix) для управления сервоприводами Dynamixel
* используя [диагностический пакет ROS](http://wiki.ros.org/diagnostics), позволяющий вашему роботу следить за собственным такие системы, как уровень заряда батареи и температуры сервоприводов
* изменение параметров робота на лету с помощью [dynamic\_reconfigure](http://wiki.ros.org/dynamic_reconfigure)
* мультиплексирование ROS тем с помощью [mux](http://wiki.ros.org/topic_tools/mux) и [yocs](http://wiki.ros.org/yocs_cmd_vel_mux), чтобы управляющие входы могли быть

  приоритетными и не работающими друг против друга

* использование [AR-тегов](http://wiki.ros.org/ar_track_alvar) для обнаружения и отслеживания объектов
* отслеживание объектов в 3D и восприятие пространственной связи между объектами

  и роботами

* управление многошарнирным манипулятором и захватом с помощью нового каркаса [MoveIt!](http://wiki.ros.org/moveit)

  включая выполнение прямой и обратной кинематики, предотвращение столкновений,

  задачи по захвату и выбору места

* работая с имитируемыми роботами и средами, используя сложный

  симулятор [Gazebo](http://wiki.ros.org/gazebo)

* создание веб-интерфейса для вашего робота с помощью [rosbridge](http://wiki.ros.org/rosbridge), HTML и Javascript.

**ПРИМЕЧАНИЕ:** В главе о Gazebo предполагается, что у нас уже есть такая модель робота, как [Kobuki](http://wiki.ros.org/kobuki) или [UBR-1](https://spectrum.ieee.org/automaton/robotics/industrial-robots/unbounded-robotics-revolutionizes-affordable-mobile-manipulation-with-ubr1), разработчики которого предоставили необходимые свойства и плагины Gazebo, чтобы справиться с симулированной физикой робота. Создание либо миров, либо плагинов Gazebo для нового робота с нуля выходит за рамки этого тома, но освещается в разделе онлайн-учебника [Gazebo](http://wiki.ros.org/simulator_gazebo/Tutorials). Некоторые из тем, которые мы рассмотрим, могут потреблять целую книгу сами по себе, так что мы сосредоточили внимание на ключевых понятиях, предоставляя при этом читателю дополнительные ссылки при желании изучить дополнительные детали. Как и в первом томе, все образцы кода написанны на Python, который, как правило, немного более доступный, чем C++ для ввода текста. После того, как вы освоите понятия, представленные в этом томе, вы сможете создать модель URDF для вашего робота, включая руку и голову для наклона и поворота, затем программировать его на выполнение ряда автономных задач и поведение, контролировать свои собственные подсистемы, расставлять приоритеты своих управляющих входов в соответствии с текущей ситуацией, отслеживать объекты в 3-мерном пространстве, понять, как запрограммировать многошарнирный манипулятор и захват, используя обратную кинематику, учитывающую коллизии, и напишите свой собственный HTML/Javascript-интерфейс, чтобы контролировать и управлять роботом с помощью веб-браузера.

