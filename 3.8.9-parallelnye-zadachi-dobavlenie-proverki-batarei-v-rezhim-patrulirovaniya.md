# 3.8.9 Параллельные задачи: Добавление проверки батареи в режим патрулирования

Теперь, когда мы знаем, как патрулировать площадь и проверять батарею, пришло время сложить их вместе. Мы хотим, чтобы сигнал разряженной батареи был на первом месте, чтобы робот остановил свой патруль и переместился на стыковочную станцию. После перезарядки мы хотим, чтобы робот продолжал свой патруль, начиная с последней точки пути, к которой он направлялся, прежде чем его прервут.

SMACH предоставляет [контейнер cогласованности](http://wiki.ros.org/smach/Tutorials/Concurrence%20container) для параллельного выполнения задач и позволяет одной задаче упреждать другую при выполнении условия. Поэтому мы настроим нашу новую машину состояния с контейнером cогласования, который будет удерживать навигационную машину и машину проверки заряда батареи. Затем мы настроим контейнер таким образом, чтобы проверка батареи могла упредить навигацию, когда уровень заряда батареи опускается ниже порога.

Прежде чем посмотреть на код, давайте попробуем. Прекратите работу узла _monitor\_battery.py_ , если он все еще запущен из предыдущего сеанса. \(Может потребоваться некоторое время, чтобы ответить на Ctrl-C, прежде чем узел в конце концов умрет\).

Если файл _fake\_turtlebot.launch_ еще не запущен, выведите его на экран. Напомним, что этот файл также запускает фальшивый симулятор батареи с 60-секундным временем работы от батареи:

```text
$ roslaunch rbx2_tasks fake_turtlebot.launch
```

Если она еще не запущена, вызовите SMACH viewer с командой:

```text
$ rosrun smach_viewer smach_viewer.py
```

Вызовите RViz с конфигурационным файлом Nav\_tasks, если он еще не запущен:

```text
$ rosrun rviz rviz -d `rospack find rbx2_tasks`/nav_tasks.rviz
```

Наконец, убедитесь, что вы видите окно RViz на переднем плане, а затем запустите скрипт _patrol\_smach\_concurrence.py_ :

```text
$ rosrun rbx2_tasks patrol_smach_concurrence.py
```

Вы должны увидеть, как робот двигается по квадрату дважды, а затем остановиться. Всякий раз, когда батарея опускается ниже порога \(по умолчанию установлен на 50 в файле _task\_setup.py_\), при этом в поле робот прервет свой патруль и направится на стыковочную станцию для перезарядки. Как только перезарядится, он продолжит патрулирование там, где остановился.

Во время выполнения скрипта вы также можете просмотреть машину состояния в SMACH просмотрщике. Изображение должно выглядеть следующим образом:

![](.gitbook/assets/izobrazhenie%20%285%29.png)

\(Если вы не видите это изображение в SMACH Viewer, выключите его и снова поднимите наверх\). Изображение на экране должно быть намного четче, чем мы можем воспроизвести здесь. Большее серое окошко слева представляет собой контейнер совпадений, который содержит навигационную машину состояния SM\_NAV внутри внутреннего окошка и состояние монитора MONITOR\_BATTERY, который подписывается на тему батареи. Меньшее зеленое окошко справа представляет машину состояния RECHARGE и содержит состояния NAV\_DOCKING\_STATION и RECHARGE\_BATTERY. Переходы между двумя состояниями могут быть более отчетливо видны на увеличенном изображении ниже:

![](.gitbook/assets/izobrazhenie%20%282%29.png)

Стрелка-дуга от красного результата перезарядки слева до зеленого окошка RECHARGE справа указывает на переход от контейнера с параллельным подключением к машине состояния RECHARGE, когда параллельное подключение приводит к результату "перезарядки".

Теперь рассмотрим код, который заставляет это работать. Ниже приведена краткая информация об общих шагах:

* создать машину состояния под названием _sm\_nav_ , которая будет обеспечивать перемещение робота из одной точки в другую
* создать вторую машину состояния, называемую _sm\_recharge_ , которая перемещает робота на стыковочную станцию и выполняет перезарядку
* создать третью машину состояния под названием _sm\_patrol_ , определяемую как контейнер согласия, который связывает машину состояния _sm\_nav_ с состоянием MonitorState, которая подписывается на тему батареи и может упредить машину состояния _sm\_nav_ при запуске машины состояния _sm\_recharge_
* наконец, создадим машину четвертого состояния под названием sm\_top, которая будет включать в себя SM\_patrol и SM\_recharge машины, а также состояние STOP, которое позволяет нам прервать весь патруль после того, как мы выполнили заданное количество циклов.

Древовидная схема нашей машины состояния выглядит вот так:

![](.gitbook/assets/izobrazhenie%20%2812%29.png)

Полный скрипт можно найти в файле [_patrol\_smach\_concurrence.py_ ](https://github.com/inmoov-ros/inmoov_ros/blob/master/robbie_test/nodes/patrol_smach_concurrence.py)в каталоге _rbx2\_tasks/nodes_.

Верхняя половина скрипта совпадает со скриптом _patrol\_smach.py_ без проверки заряда батареи. Так что давайте теперь посмотрим на строки, которые приносят в стыковочную станцию и проверки батареи.

```text
# Создать состояние MoveBaseAction для док-станции
nav_goal = MoveBaseGoal()
nav_goal.target_pose.header.frame_id = 'map' nav_goal.target_pose.pose =
self.docking_station_pose
nav_docking_station = SimpleActionState('move_base', MoveBaseAction,
goal=nav_goal, result_cb=self.move_base_result_cb, exec_timeout =
rospy.Duration(20.0), server_wait_timeout=rospy.Duration(10.0))
```

Как и в случае с четырьмя путевыми точками навигации, мы создаем SimpleActionState, обернув действие move\_base, которое доставляет робота на стыковочную станцию. Расположение стыковочной станции на карте \(self.docking\_station\_pose\) устанавливается в нашем установочном файле _task\_setup.py_ , входящем в верхнюю часть программы.

```text
self.sm_nav.register_transition_cb(self.nav_transition_cb, cb_args=[])
```

Далее мы регистрируем функцию обратного вызова на машине состояния sm\_nav, которая работает при переходе в состояние. Функция обратного вызова выглядит так:

```text
def nav_transition_cb(self, userdata, active_states, *cb_args):
self.last_nav_state = active_states
```

Как видно, функция просто сохраняет последнее активное состояние в переменной self.last\_nav\_state. Это позволит нам продолжить патрулирование там, где мы остановились после того, как робот завершит перезарядку.

Далее, давайте посмотрим на различные определения машин состояния в обратном порядке, в котором они появляются в скрипте. Это происходит потому, что SMACH определяет иерархические машины состояний в терминах машин состояний компонентов, которые создаются заранее. Однако, с точки зрения понимания сценария, мы склонны думать сверху вниз в иерархии.

Верхний уровень машины состояния sm\_top выглядит следующим образом:

```text
# Создайте машину состояния верхнего уровня
self.sm_top = StateMachine(outcomes=['succeeded', 'aborted', 'preempted'])
# Добавить машины Nav_patrol, sm_recharge и Stop() в sm_top
with self.sm_top:
StateMachine.add('PATROL', self.nav_patrol,
transitions={'succeeded':'PATROL','recharge':'RECHARGE',
'stop':'STOP'})
StateMachine.add('RECHARGE', self.sm_recharge,
transitions={'succeeded':'PATROL'})
StateMachine.add('STOP', Stop(), transitions={'succeeded':''})
```

Здесь мы видим, что машина общего состояния состоит из трех компонентов: машина Nav\_patrol с надписью 'PATROL', машина sm\_recharge с надписью 'RECHARGE' и функционально определенная машина состояния с надписью 'STOP'. Более того, таблица перехода для машины nav\_patrol указывает, что результат 'succeeded' должен привести к состоянию PATROL, в то время как результат 'recharge' должен перейти в состояние RECHARGE, а результат 'stop' должен запустить состояние STOP. В состоянии RECHARGE определен только один переход, который должен вернуться в состояние PATROL, если исход перезарядки "удался". Наконец, состояние STOP переходит в состояние "Пусто", тем самым завершая работу всей машины состояния.

Теперь давайте разобьем каждое из этих состояний компонентов и машины состояния. Последнее состояние с пометкой STOP определено ранее в сценарии и выглядит так:

```text
class Stop(State):
def __init__(self):
State.__init__(self,
outcomes=['succeeded','aborted','preempted']) pass def
execute(self, userdata): rospy.loginfo("Shutting down the state
machine")
return 'succeeded'
```

Здесь мы создаем SMACH состояние, которое просто распечатывает сообщение и возвращает "успешно". Это единственная функция дает нам состояние, в которое мы можем перейти, когда мы закончим все патрули.

Состояние RECHARGE - это другая машина состояния, называемая _sm\_recharge_ , которая определяется следующим образом:

```text
with self.sm_recharge:
StateMachine.add('NAV_DOCKING_STATION', nav_docking_station,
transitions={'succeeded':'RECHARGE_BATTERY'})
StateMachine.add('RECHARGE_BATTERY',
ServiceState('battery_simulator/set_battery_level', SetBatteryLevel,
100, response_cb=self.recharge_cb), transitions={'succeeded':''})
```

Первое состояние доставляет робота на стыковочную станцию с помощью функции _Nav\_docking\_station_ SimpleActionState, а второе состояние моделирует перезарядку с помощью SMACH ServiceState для вызова сервиса _set\_battery\_level_ со значением 100 \(полная зарядка\).

Наконец, состояние PATROL определяется машиной состояния _Nav\_patrol_ , которая выглядит следующим образом:

```text
self.nav_patrol = Concurrence(outcomes=['succeeded', 'recharge', 'stop'],
default_outcome='succeeded',
child_termination_cb=self.concurrence_child_termination_cb,
outcome_cb=self.concurrence_outcome_cb)
with self.nav_patrol:
Concurrence.add('SM_NAV', self.sm_nav)
Concurrence.add('MONITOR_BATTERY', MonitorState("battery_level", Float32,
self.battery_cb))
```

Здесь мы определили машину состояния _Nav\_patrol_ как контейнер согласования SMACH. В данном случае контейнер согласования включает в себя машину состояния навигации и SMACH MonitorState, который подписывается на тему уровня заряда батареи. Это настраивает машину состояния _Nav\_patrol_ на перемещение робота по квадрату при мониторинге уровня заряда батареи.

Состояние MonitorState принимает три аргумента: тема, на которую мы хотим подписаться, тип сообщения для этой темы и функция обратного вызова, которая вызывается при получении сообщения в подписанной теме. Другими словами, оно завершает стандартную операцию подписки ROS. В нашем случае функция обратного вызова, _self.battery\_cb_ выглядит следующим образом:

```text
def battery_cb(self, userdata, msg): if
msg.data < self.low_battery_threshold:
self.recharging = True
return False
else: self.recharging
= False
return True
```

Здесь мы видим, что функция обратного вызова возвращает False, если уровень заряда батареи опускается ниже порога или True иначе. Мы также устанавливаем флаг, указывающий, перезаряжаемся ли мы, чтобы не считать перезарядку в сравнении с общим показателем успешности навигации.

Последний вопрос: как при низком заряде батареи предвосхитить текущую задачу навигации, запустить задачу перезарядки, а затем возобновить предыдущую задачу навигации? Вы заметите, что контейнер согласования определяет две функции обратного вызова: функцию child\_termination\_cb, которая срабатывает при завершении любого из дочерних состояний; и функцию outcome\_cb, которая срабатывает при завершении всех дочерних состояний. Давайте посмотрим на это поочередно.

```text
def concurrence_child_termination_cb(self, outcome_map):
# Если текущая задача навигации выполнена успешно, верните True
if outcome_map['SM_NAV'] == 'succeeded': return True
# Если состояние MonitorState возвращает False (invalid), сохраните текущую цель навигации и перезарядите робота, если outcome_map['MONITOR_BATTERY'] == 'invalid':
rospy.loginfo("LOW BATTERY! NEED TO RECHARGE...") if
self.last_nav_state is not None:
self.sm_nav.set_initial_state(self.last_nav_state, UserData())
return True else: return False
```

Обратный звонок о завершении работы ребенка срабатывает, когда возвращается либо sm\_nav машина, либо батарея MonitorState, поэтому мы должны проверить любое из этих состояний. Карта результатов индексируется по именам машин состояния, составляющих контейнер Согласованности, которые в нашем случае являются SM\_NAV и MONITOR\_BATTERY. Таким образом, сначала мы проверяем состояние SM\_NAV машины и, если это удалось \(т.е. робот только что добрался до точки маршрута\), мы возвращаем True. В противном случае, мы проверяем состояние монитора батареи. Вспомните, что MonitorState отображает True как действительное и False как недействительное. Если мы видим результат недействительный \(батарея упала ниже порога\), мы сбрасываем начальное состояние sm\_nav машины, чтобы быть последней успешной целью навигации и возвращаем True.

Обратный вызов выполняется, когда и машина sm\_nav, и MonitorState завершили работу. В нашем случае функция обратного вызова выглядит так:

```text
def concurrence_outcome_cb(self, outcome_map): # если заряд батареи ниже порога, верните результат "перезарядки" если outcome_map['MONITOR_BATTERY']
== 'invalid': return 'recharge' # В противном случае, если последняя цель навигации достигнута, верните "succeed" или "stop" если outcome_map['SM_NAV'] ==
'succeeded': self.patrol_count += 1
rospy.loginfo("FINISHED PATROL LOOP: " + str(self.patrol_count))
# Если мы не закончили все патрули, начните сначала
if self.n_patrols == -1 or self.patrol_count < self.n_patrols:
self.sm_nav.set_initial_state(['NAV_STATE_0'], UserData())
return 'succeeded' # В противном случае, мы закончили патрулирование, так что возвращайтесь 'stop' else:
self.sm_nav.set_initial_state(['NAV_STATE_4'], UserData())
return 'stop'
# Recharge if all else fails
else: return 'recharge'
```

Как и в случае с обратным вызовом ребенка, мы тестируем карту результатов для каждого из состояний согласия. В этом случае мы сначала тестируем результат MONITOR\_BATTERY, и если он недействителен \(батарея разряжена\), мы возвращаем результат "перезарядки". Напомним, что в нашей машине состояния верхнего уровня этот результат приведет к переходу в состояние RECHARGE, которое, в свою очередь, определяется машиной состояния sm\_recharge, которая переместит робота на стыковочную станцию. В противном случае, мы тестируем результат состояния SM\_NAV и, если он возвращается "успешно", что означает, что мы прибыли в точку маршрута, мы затем тестируем, чтобы увидеть, закончили ли мы определенное количество патрулей и можем ли мы остановить или продолжить патрулирование.

