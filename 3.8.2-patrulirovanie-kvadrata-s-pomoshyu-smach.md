# 3.8.2 Патрулирование квадрата с помощью SMACH

В томе 1 мы запрограммировали нашего робота на навигацию по квадрату, используя различные методы, включая действия _move\_base_. А ранее в этой главе мы использовали скрипт на Python, чтобы сделать то же самое, одновременно контролируя имитируемый уровень заряда батареи. Давайте теперь посмотрим, как мы можем использовать SMACH для достижения той же цели.

В этом разделе мы пропустим проверку батареи и просто передвинем робота по квадрату. В следующем разделе мы добавим проверку батареи и дадим роботу возможность подзарядиться, когда это необходимо.

Один из способов концептуализации проблемы патрулирования состоит в том, что мы хотим, чтобы робот находился в одном из четырех состояний, а именно в положениях, которые определяют четыре угла квадрата. Более того, мы хотим, чтобы робот проходил через эти состояния в определенном порядке. Эквивалентно можно сказать, что мы хотим, чтобы робот выполнял четыре задачи, а именно, последовательно перемещался в каждое из угловых положений.

Назовем четыре состояния от _NAV\_STATE\_0_ до _NAV\_STATE\_3_. Затем наша машина состояний будет определена следующими состояниями и переходами:

_NAV\_STATE\_0 → NAV\_STATE\_1_ 

_NAV\_STATE\_1 → NAV\_STATE\_2_

 _NAV\_STATE\_2 → NAV\_STATE\_3_

 _NAV\_STATE\_3 → NAV\_STATE\_0_

Здесь мы определили последний переход, который приведет нас обратно в стартовое состояние, что, таким образом, заставляет всю машину состояния повторить цикл. Если вместо этого мы хотим, чтобы робот остановился после перемещения по квадрату всего один раз, мы можем определить другое состояние _NAV\_STATE\_4_ , чтобы он имел ту же позицию цели, что и _NAV\_STATE\_0_ , а затем изменить последний переход выше на:

_NAV\_STATE\_3 → NAV\_STATE\_4_

Затем мы могли бы завершить работу машины \(и, следовательно, остановить робота\), добавив окончательный переход в состояние "пустота":

_NAV\_STATE\_4 → ' '_

В SMACH переходы зависят от исхода предыдущего состояния. В случае перемещения нашего робота из одного места в другое, результат может быть "успешным", "прерванным" или "вытесненным".

Эти идеи реализованы в скрипте _patrol\_smach.py_, который находится в каталоге _rbx2\_tasks/nodes_. Чтобы сэкономить место, мы не будем отображать весь листинг, а сконцентрируемся на ключевых разделах.

В блоке импорта, расположенном в верхней части сценария, нам нужно ввести SMACH-объекты, которые мы хотим использовать:

```text
from smach import StateMachine from smach_ros import
SimpleActionState, IntrospectionServer
```

Нам понадобится объект StateMachine для построения машины общего состояния, SimpleActionState для обёртывания наших звонков на move\_base и IntrospectionServer, чтобы мы могли использовать smach\_viewer.

Как вы знаете из [онлайн-руководства](http://wiki.ros.org/smach/Tutorials/SimpleActionState), тип SimpleActionState позволяет нам обернуть обычное действие ROS в состояние SMACH. Если предположить, что мы уже присвоили угловые позиции списку Python, называемым путевыми точками, то блок кода, который превращает эти позиции в простые состояния действия, выглядит следующим образом:

```text
nav_states = list()
for waypoint in waypoints:
nav_goal = MoveBaseGoal()
nav_goal.target_pose.header.frame_id = 'map'
nav_goal.target_pose.pose = waypoint
move_base_state = smach_ros.SimpleActionState('move_base', MoveBaseAction,
goal=nav_goal, exec_timeout=rospy.Duration(10.0))
nav_states.append(move_base_state)
```

Сначала мы создаём пустой список, называемый nav\_states, для хранения наших навигационных состояний, по одному для каждого угла квадрата. Затем мы проходим через каждую из путевых точек, создавая стандартный MoveBaseGoal, используя эту путевую точку как нужную позу. Затем мы превращаем эту цель в SMACH состояние, используя утверждение:

```text
move_base_state = smach_ros.SimpleActionState('move_base', MoveBaseAction,
goal=nav_goal, exec_timeout=rospy.Duration(10.0))
```

где мы использовали тип состояния SimpleActionState, чтобы обернуть действие MoveBaseAction в состояние. Конструктор класса SimpleActionState принимает имя темы действия в качестве первого аргумента, а тип действия в качестве второго аргумента. Он также поддерживает аргументы _keyword arguments goal_ и _exec\_timeout_ для указания цели действия и времени, в течение которого мы хотим дождаться его достижения \(10 секунд в случае, описанном выше\). Наконец, мы добавляем состояние в список _Nav\_states._

Предопределенные результаты для SimpleActionState являются успешными, отменяются или упреждаются. Следующим шагом является построение общей машины состояния с использованием этих результатов и состояний:

```text
# Инициализация машины состояния
self.sm_patrol = StateMachine(outcomes=['succeeded','aborted','preempted'])
# Добавить состояния в машину состояний с соответствующими переходами 
with self.sm_patrol:
StateMachine.add('NAV_STATE_0', nav_states[0],
transitions={'succeeded':'NAV_STATE_1','aborted':'NAV_STATE_1'})
StateMachine.add('NAV_STATE_1', nav_states[1],
transitions={'succeeded':'NAV_STATE_2','aborted':'NAV_STATE_2'})
StateMachine.add('NAV_STATE_2', nav_states[2],
transitions={'succeeded':'NAV_STATE_3','aborted':'NAV_STATE_3'})
StateMachine.add('NAV_STATE_3', nav_states[3],
transitions={'succeeded':'NAV_STATE_0','aborted':'NAV_STATE_0'})
```

Сначала мы инициализируем нашу патрульную машину состояния с возможными последствиями "успешно", "прервано" и "вытеснено". Реальный результат будет определяться состояниями, которые мы добавим в машину состояний, и какими результатами они будут получены при выполнении.

Далее мы добавляем каждое состояние навигации в машину состояния вместе со словарем переходов от исхода к следующему состоянию. Первый аргумент в каждой строке - произвольное имя, которое мы присваиваем состоянию, так что переходам есть на что ссылаться. По условию, эти имена состояний записываются в верхнем регистре. Например, в первой строке выше добавляется состояние nav\_states\[0\] к машине состояния и присваивается ему имя _NAV\_STATE\_0_. Переходы для этого состояния говорят нам о том, что если состояние успешно \(робот добирается до места расположения цели\), то мы хотим, чтобы следующим состоянием было _NAV\_STATE\_1_, которое определено во второй строке и представляет собой вторую позицию цели, хранящуюся в состоянии nav\_states\[1\].

Обратите внимание, как мы также отображаем результат "отменен" до следующего состояния. Несмотря на то, что это необязательно и не всегда желательно, это хорошо работает с целями MoveBase, так как базовый планировщик не всегда может преуспеть в приведении робота к текущей цели из-за препятствий или временных ограничений. В таких случаях результат будет прерван, и вместо того, чтобы просто остановить робота, мы переходим к следующей цели.

Обратите внимание также на то, как переход в конечное состояние возвращается в первое состояние, _NAV\_STATE\_0_. В этом случае машина состояния и робот будут продолжать обходить квадрат бесконечно. Если мы хотим, чтобы робот остановился после первого цикла, мы можем создать следующую машину состояний:

```text
with self.sm_patrol:
StateMachine.add('NAV_STATE_0', nav_states[0],
transitions={'succeeded':'NAV_STATE_1','aborted':'NAV_STATE_1'})
StateMachine.add('NAV_STATE_1', nav_states[1],
transitions={'succeeded':'NAV_STATE_2','aborted':'NAV_STATE_2'})
StateMachine.add('NAV_STATE_2', nav_states[2],
transitions={'succeeded':'NAV_STATE_3','aborted':'NAV_STATE_3'})
StateMachine.add('NAV_STATE_3', nav_states[3],
transitions={'succeeded':'NAV_STATE_4','aborted':'NAV_STATE_4'})
StateMachine.add('NAV_STATE_4', nav_states[0],
transitions={'succeeded':'','aborted':''})
```

Конечному состоянию _NAV\_STATE\_4_ присваивается то же самое состояние позы, что и начальная точка, и мы отображаем оба результата в пустое состояние, таким образом, завершая работу машины состояния и останавливая робота. Скрипт _patrol\_smach.py_ реализует эту версию машины состояний, но помещает выполнение в цикл, который позволяет нам контролировать количество раз, когда робот завершает свой патруль, как мы покажем дальше.

Для выполнения машины состояния мы используем петлю:

```text
while self.n_patrols == -1 or self.patrol_count < self.n_patrols:
sm_outcome = self.sm_patrol.execute()
self.patrol_count += 1
rospy.loginfo("FINISHED PATROL NUMBER: " + str(self.patrol_count))
```

Параметр _self.n\_patrols_ определен в нашем файле task\_setup.py, который в свою очередь считывает его с сервера параметров ROS со значением по умолчанию 3. \(Мы используем специальное значение -1, если хотим, чтобы робот зациклился навсегда\) Счетчик _self.patrol\_count_ также определен в файле _task\_setup.py_ и инициализирован на 0.

При каждом проходе через цикл мы запускаем _self.sm\_patrol.exec\(\)_. Метод execute\(\) приводит в движение машину состояния. Если машина завершает работу, как это происходит выше, после перехода в конечное состояние, то общий результат для машины состояния будет доступен в переменной _sm\_outcome_.

Обратите внимание, что в отличие от обычного сценария, мы не можем просто разместить некоторое время петлю вокруг фактических состояний нашей машине состояния, так как это приведет к петлеобразованию через построение состояний еще до того, как они будут запущены.

Мы также будем склонны добавлять следующие пары строк в большинство наших скриптов:

```text
intro_server = IntrospectionServer('nav_square', self.sm_patrol, '/SM_ROOT')
intro_server.start()
```

Сервер SMACH Introspection позволяет нам просматривать запущенную машину состояния в графической утилите _smach\_viewer_ , как мы увидим ниже.

