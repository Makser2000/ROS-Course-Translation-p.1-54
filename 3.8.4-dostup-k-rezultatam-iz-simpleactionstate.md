# 3.8.4 Доступ к результатам из SimpleActionState

В нашей машине текущего состояния мы решили перейти к следующему состоянию, даже если текущий переход придется прервать. Но, возможно, было бы полезно вести подсчет того, как часто цель была успешной. Например, если это был патрульный робот, и показатель успешности упал ниже какого-то порога, то мы можем заподозрить, что с роботом что-то не так или что-то мешает ему.

Конструктор SMACH SimpleActionState позволяет нам назначить функцию обратного вызова для получения результата действия. Синтаксис выглядит следующим образом:

```text
move_base_state = SimpleActionState('move_base', MoveBaseAction,
goal=nav_goal, result_cb=self.move_base_result_cb)
```

Обратите внимание, как мы используем ключевое слово _result\_cb_ для назначения функции для обработки результата. Наша функция _move\_base\_result\_cb_ выглядит следующим образом:

```text
def move_base_result_cb(self, userdata, status, result):
if status == actionlib.GoalStatus.SUCCEEDED:
self.n_succeeded += 1 elif status
== actionlib.GoalStatus.ABORTED:
self.n_aborted += 1 elif status ==
actionlib.GoalStatus.PREEMPTED:
self.n_preempted += 1
try: rospy.loginfo("Success rate: " + str(100.0 *
self.n_succeeded / (self.n_succeeded + self.n_aborted +
self.n_preempted))) except: pass
```

Функция обратного вызова принимает три аргумента: текущие данные пользователя \(которые мы рассмотрим позже\), а также статус и результат, возвращаемые базовым действием ROS \(в данном случае, move\_base\). Как оказалось, действие move\_base не использует поле результата. Вместо этого оно помещает результаты в поле статуса, поэтому наше тестовое состояние выше проверяет значение поля статуса.

Как видно из приведенного кода, наш обратный вызов просто увеличивает счетчики для количества успешных, прерванных или вытесненных попыток move\_base. Мы также распечатываем процент успеха.



