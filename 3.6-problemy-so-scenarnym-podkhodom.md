# 3.6 Проблемы со скриптовым подходом

Основная проблема стандартного скриптового подхода, описанного выше, заключается в том, что нам приходилось закапывать проверку заряда батареи глубоко в рутине навигации. В то время как для данного конкретного примера это работает нормально, это становится менее эффективным, так как мы добавляем больше задач к поведению робота. Например, предположим, что мы хотим, чтобы робот сканировал присутствие человека в каждой точке маршрута, панорамируя камеру влево и вправо, прежде чем переходить к следующему местоположению. Тогда наш патрульный режим может выглядеть вот так:

```text
def patrol(): for
location in waypoints:
nav_to_waypoint(location)
scan_for_humans()
```

Пока камера панорамируется туда-сюда, нам все еще нужно следить за уровнем заряда батареи, но теперь мы больше не ставим перед собой цель move\_base. Это означает, что нам нужно добавить вторую проверку заряда батареи, на этот раз в процедуру панорамирования головы. Если в этот момент уровень заряда батареи опустится ниже порога, нам больше не нужно будет отменять цель навигации, вместо этого нам нужно обновить камеру перед тем, как переместиться на базовую станцию.

Для каждой дополнительной задачи нам необходимо добавлять еще одну проверку батареи, что приводит к избыточности в коде и делает нашу общую систему управления задачами менее модульной. Концептуально, проверка заряда батареи должна появляться на видном месте в верхней части нашей иерархии задач, и нам действительно нужно проверять уровень заряда батареи только один раз при каждом прохождении через список задач.

Еще одним недостатком скриптового подхода является то, что мы делаем прямые звонки в ROS действия, темы и услуги, а не через многоразовые обертки, которые скрывают общие детали. Например, помимо подписки на тему "Уровень заряда батареи", вполне вероятно, что мы также будем подписываться на другие темы, генерируемые дополнительными датчиками, такие как  глубина камеры, датчики удара или лазерный сканер. Все эти подписчики имеют схожие настройки шаблона с точки зрения названия темы, типа темы и функции обратного вызова. Фреймворки задач, например SMACH определяет обёртки для ROS тем, сервисов и действий, которые заботятся об установке деталей, что позволяет добавлять или удалять эти объекты из задания исполнительный без необходимости повторять многочисленные строки кода.



