# 3.5 Патрульный бот, использующий стандартный скрипт

Наш скрипт подпишется на тему уровня заряда батареи с функцией обратного вызова, которая устанавливает флаг _low\_battery_ в значение True, если уровень заряда упал ниже заданного порога следующим образом:

```text
def battery_cb(self, msg): if msg.data
< self.low_battery_threshold:
self.low_battery = True else:
self.low_battery = False
```

Эта проверка выполняется с той же частотой, с которой принимаются сообщения по теме уровня заряда батареи.

В то же время, наш главный контур управления может стать похожим на это:

```text
while n_patrols < max_patrols:
if low_battery:
recharge() else:
patrol()
```

В начале каждого патруля мы проверяем уровень заряда батареи и при необходимости перезаряжаем его. В противном случае, мы начинаем патрулирование. Конечно, эта простая стратегия не сработает на практике, так как батарея, скорее всего, разрядится в промежутках между проверками батареи, когда робот частично обходит курс. Посмотрим, как мы можем исправить эту проблему.

Рутина _patrol\(\)_ перемещает робота через последовательность путевых точек что-то вроде этого:

```text
def patrol(): for
location in waypoints:
nav_to_waypoint(location)
```

Когда мы записываем это таким образом, мы видим, что мы должны поместить проверку батареи внутрь функции _Nav\_to\_waypoint\(\)_ :

```text
def nav_to_waypoint(location):
if low_battery:
recharge() else:
move_to(location)
```

По крайней мере, теперь мы проверяем уровень заряда батареи перед тем, как перейти к каждой точке маршрута. Однако, функция _move\_to\(location\)_ может занять некоторое время в зависимости от того, как далеко расположена следующая путевая точка. Так что нам действительно нужно поместить проверку заряда батареи еще глубже и поместить ее в рутину _move\_to\(\)_.

В ROS функция _move\_to\(\)_ , скорее всего, будет реализована как вызов сервера MoveBaseAction, так что проверка заряда батареи будет производиться внутри обратного вызова для клиента _move\_base_. Результат будет выглядеть примерно так:

```text
move_base.send_goal(goal, feedback_cb=self.nav_feedback_cb)
def nav_feedback_cb(self, msg):
if self.low_battery:
self.recharge()
```

Теперь мы проверяем состояние батареи каждый раз, когда получаем сообщение обратной связи от сервера MoveBaseAction, которое должно быть достаточно частым, чтобы избежать разряда батареи. Функция _recharge\(\)_ отменяет текущую цель _move\_base_ перед отправкой новой цели на сервер MoveBaseAction для навигации робота к стыковочной станции для зарядки.

Весь описанный здесь скрипт находится в файле _patrol\_script.py_ , расположенном в каталоге _rbx2\_tasks/nodes_.

Скрипт достаточно прост и не будет описан в деталях. Тем не менее, вы можете протестировать его следующим образом.

Сначала запустите фальшивый TurtleBot в симуляторе ArbotiX с помощью файла _fake\_turtlebot.launch_ в подкаталоге _rbx2\_tasks/launch_. Этот файл вызовет фальшивый TurtleBot, сервер действий _move\_base_ с пустой картой, и узел симулятора батареи со стандартным временем выполнения 60 секунд:

```text
$ roslaunch rbx2_tasks fake_turtlebot.launch
```

Далее вызываем RViz с помощью конфигурационного файла _nav\_tasks.rviz_ :

```text
$ rosrun rviz rviz -d `rospack find rbx2_tasks`/nav_tasks.rviz
```

Наконец, запустите скрипт _patrol\_script.py_ :

```text
$ rosrun rbx2_tasks patrol_script.py
```

Вид в RViz должен выглядеть примерно так:

![](.gitbook/assets/izobrazhenie%20%2810%29.png)

Робот должен выполнить две петли вокруг квадрата, контролируя при этом уровень заряда батареи. Всякий раз, когда заряд батареи опускается ниже порога, определенного в сценарии \(50\), робот будет переходить к круговой стыковочной станции в центре площади. После подзарядки \(уровень заряда батареи установлен на 100\), робот должен продолжить патрулирование с того места, где он остановился. Например, если он не совсем доехал до второй точки маршрута, когда его заставили перезарядиться, он должен сначала вернуться к этой точке пути, а затем продолжить цикл.

